use crate::ts::{ExportConfiguration, TsExportError};
use crate::*;
use once_cell::sync::Lazy;
use std::collections::BTreeMap;
use std::sync::Mutex;

/// Global type store for collecting custom types to export.
///
/// Populated by `#[ctor]` functions defined in the [`Type`](derive@crate::Type) macro.
pub static TYPES: Lazy<Mutex<BTreeMap<TypeSid, DataType>>> = Lazy::new(Default::default);

/// Exports all types in the [`TYPES`](static@crate::export::TYPES) map to the provided TypeScript file.
pub fn ts(path: &str) -> Result<(), TsExportError> {
    ts_with_cfg(path, &ExportConfiguration::default())
}

/// Exports all types in the [`TYPES`](static@crate::export::TYPES) map to the provided TypeScript file but allow you to provide a configuration for the exporter.
pub fn ts_with_cfg(path: &str, conf: &ExportConfiguration) -> Result<(), TsExportError> {
    let mut out = "// This file has been generated by Specta. DO NOT EDIT.\n\n".to_string();

    let export_by_default = conf.export_by_default.unwrap_or(true);
    let types = TYPES.lock().expect("Failed to acquire lock on 'TYPES'");
    let types = types
        .values()
        .filter_map(|v| match v {
            DataType::Object(CustomDataType::Named { name, export, .. }) => {
                export.unwrap_or(export_by_default).then(|| (name, v))
            }
            DataType::Enum(CustomDataType::Named { name, export, .. }) => {
                export.unwrap_or(export_by_default).then(|| (name, v))
            }
            DataType::Tuple(CustomDataType::Named { name, export, .. }) => {
                export.unwrap_or(export_by_default).then(|| (name, v))
            }
            DataType::Placeholder => {
                unreachable!("Placeholder type should never be returned from the Specta functions!")
            }
            _ => None,
        })
        .collect::<BTreeMap<_, _>>();

    for (_, typ) in types {
        out += &ts::export_datatype(conf, typ)?;
        out += "\n\n";
    }

    std::fs::write(path, out).map_err(Into::into)
}
