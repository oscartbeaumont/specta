use crate::ts::{ExportConfiguration, TsExportError};
use crate::*;
use once_cell::sync::Lazy;
use std::collections::BTreeMap;
use std::sync::Mutex;

/// Global type store for collecting custom types to export.
///
/// Populated by `#[ctor]` functions defined in the [`Type`](derive@crate::Type) macro.
pub static TYPES: Lazy<Mutex<(TypeDefs, Vec<ExportError>)>> = Lazy::new(Default::default);

/// Exports all types in the [`TYPES`](static@crate::export::TYPES) map to the provided TypeScript file.
pub fn ts(path: &str) -> Result<(), TsExportError> {
    ts_with_cfg(path, &ExportConfiguration::default())
}

/// Exports all types in the [`TYPES`](static@crate::export::TYPES) map to the provided TypeScript file but allow you to provide a configuration for the exporter.
pub fn ts_with_cfg(path: &str, conf: &ExportConfiguration) -> Result<(), TsExportError> {
    let mut out = "// This file has been generated by Specta. DO NOT EDIT.\n\n".to_string();

    let export_by_default = conf.export_by_default.unwrap_or(true);
    let types = TYPES.lock().expect("Failed to acquire lock on 'TYPES'");

    for err in types.1.clone() {
        return Err(err.into());
    }

    let types = types
        .0
        .clone()
        .into_iter()
        .filter(|(_, v)| match v {
            Some(v) => v.export.unwrap_or(export_by_default),
            None => {
                unreachable!("Placeholder type should never be returned from the Specta functions!")
            }
        })
        .collect::<BTreeMap<_, _>>();

    for (ty_name, l0, l1) in detect_duplicate_type_names(&types) {
        return Err(TsExportError::DuplicateTypeName(ty_name, l0, l1));
    }

    for (_, typ) in types {
        out += &ts::export_datatype(
            conf,
            &match typ {
                Some(v) => v,
                None => unreachable!(),
            },
        )?;
        out += "\n\n";
    }

    std::fs::write(path, out).map_err(Into::into)
}
